<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Tragwerks-Stabilisator (v22: 3D Labels & Raster)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { margin: 0; font-family: 'Segoe UI', sans-serif; display: flex; height: 100vh; overflow: hidden; background-color: #f8f9fa; }
        #left-panel { width: 45%; height: 100%; position: relative; border-right: 1px solid #ddd; }
        #right-panel { width: 55%; height: 100%; display: flex; flex-direction: column; background: white; }
        #view3d { width: 100%; height: 100%; background: #eef2f5; }

        /* Header-Stil */
        #calc-header { padding: 15px 20px; background: #fff; border-bottom: 1px solid #ddd; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .formula-box { background: #f0f7ff; padding: 15px; border-radius: 8px; border-left: 5px solid #0056b3; font-family: monospace; }
        .formula-title { font-size: 1.3em; font-weight: bold; color: #333; margin-bottom: 8px; }
        .formula-desc { font-size: 0.9em; color: #555; line-height: 1.6; }
        .val-highlight { color: #d63384; font-weight: bold; font-size: 1.2em; }
        .badge { background: #0056b3; color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.7em; vertical-align: text-top; margin-left: 5px;}

        /* Toolbar-Stil */
        #toolbar { padding: 10px 20px; background: #e9ecef; border-bottom: 1px solid #ccc; display: flex; justify-content: space-between; align-items: center; }
        select { padding: 8px; border-radius: 4px; border: 1px solid #aaa; font-weight: bold; }
        button { padding: 8px 15px; border: none; border-radius: 4px; cursor: pointer; color: white; margin-left: 5px; font-weight: bold; transition: 0.2s; font-size: 13px; }
        .btn-new { background: #6c757d; } 
        .btn-check { background: #6610f2; color: white; } 
        .btn-solve { background: #28a745; } 
        .btn-reset { background: #dc3545; }
        button:hover { transform: translateY(-1px); opacity: 0.9; }

        /* Statusleiste */
        #status-bar { padding: 12px 20px; background: #fff3cd; color: #333; font-size: 14px; border-bottom: 1px solid #ffeeba; min-height: 20px; }
        #draw-area { flex: 1; overflow-y: auto; padding: 20px; }
        
        /* 2D Panel-Gruppe */
        .panel-group { margin-bottom: 25px; border: 1px solid #eee; border-radius: 8px; padding: 15px; background: #fff; }
        .panel-title { font-weight: bold; display: block; margin-bottom: 10px; color: #444; border-bottom: 2px solid #eee; padding-bottom: 5px; }
        .svg-container { display: flex; flex-wrap: wrap; gap: 20px; justify-content: center; }
        .svg-wrapper { text-align: center; }
        
        svg { border: 1px solid #ccc; background: white; user-select: none; }
        
        /* 2D Knoten-Stil (Verkleinert: r=4) */
        circle.node { fill: #fff; stroke: #333; stroke-width: 1.5px; cursor: pointer; transition: 0.2s; }
        circle.node:hover { fill: #aaa; r: 6; } 
        circle.node.selected { fill: #ff0000; stroke: #ff0000; r: 5; }
        circle.node.ground { fill: #bbb; stroke: #888; cursor: pointer; } 
        
        line.frame { stroke: #e0e0e0; stroke-width: 2px; }
        line.brace { stroke: #dc3545; stroke-width: 4px; stroke-linecap: round; cursor: pointer; transition: stroke 0.2s; }
        line.brace:hover { stroke: #ff0000; stroke-width: 6px; }
        line.solution-brace { stroke: #198754; stroke-width: 3px; stroke-dasharray: 5,5; opacity: 0.8; pointer-events: none; }
    </style>
</head>
<body>

<div id="left-panel"><div id="view3d"></div></div>

<div id="right-panel">
    <div id="calc-header">
        <div class="formula-box">
            <div class="formula-title">
                p<sub>erf</sub> = 3 · k - p<sub>vorh</sub> = <span id="perf-val" class="val-highlight">0</span>
                <span class="badge">Formel nach Vorlesung</span>
            </div>
            <div class="formula-desc">
                • <strong>k (Knoten):</strong> <span id="k-val">0</span> (Anz. Knoten ohne Auflagerknoten)<br>
                • <strong>p<sub>vorh</sub> (Stäbe):</strong> <span id="pvorh-val">0</span> 
                (Anzahl Stäbe inkl. Stützen am Boden)
            </div>
        </div>
    </div>

    <div id="toolbar">
        <select id="modeSelect" onchange="resetUserBraces()">
            <option value="scheiben">Scheibenstabilisierung</option>
            <option value="reihen">Reihenstabilisierung</option>
        </select>
        <div>
            <button class="btn-new" onclick="generateNewProblem()">Neues System</button>
            <button class="btn-reset" onclick="resetUserBraces()">Zurücksetzen</button>
            <button class="btn-solve" onclick="showSolution()">Lösung zeigen</button>
            <button class="btn-check" onclick="analyzeStructure()">System prüfen</button>
        </div>
    </div>
    
    <div id="status-bar">Bereit.</div>
    <div id="draw-area"></div>
</div>

<script>
    let scene, camera, renderer, controls;
    let structureData = {};
    let userBraces = []; 
    let nodeList = []; 
    let selectedNode = null; 
    let elementMeshes = [];
    let perfValue = 0;

    const frameGroup = new THREE.Group();
    const userBraceGroup = new THREE.Group();
    const solutionBraceGroup = new THREE.Group();
    const labelGroup = new THREE.Group(); // Gruppe für Labels

    init3D();
    generateNewProblem();

    // --- 1. 3D Umgebung Initialisierung ---
    function init3D() {
        const container = document.getElementById('view3d');
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xeef2f5);

        const aspect = container.clientWidth / container.clientHeight;
        const d = 40; 
        camera = new THREE.OrthographicCamera(-d*aspect, d*aspect, d, -d, 1, 1000);
        camera.position.set(50, 50, 50); 
        camera.lookAt(scene.position);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;

        scene.add(new THREE.AmbientLight(0xffffff, 0.8));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight.position.set(20, 50, 20);
        scene.add(dirLight);

        scene.add(frameGroup);
        scene.add(userBraceGroup);
        scene.add(solutionBraceGroup);
        scene.add(labelGroup);

        animate();
        window.addEventListener('resize', () => {
            const aspect = container.clientWidth / container.clientHeight;
            camera.left = -d*aspect; camera.right = d*aspect;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });
    }
    function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }

    // --- Funktion zur Erstellung von Textlabels (Canvas Sprite) ---
    function createLabel(text, x, y, z, color='#333', size=1.5) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 256; canvas.height = 64; // Breite erhöht für längere Texte
        ctx.font = 'Bold 32px Arial';
        ctx.fillStyle = color;
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillText(text, 128, 32);
        
        const tex = new THREE.CanvasTexture(canvas);
        const mat = new THREE.SpriteMaterial({ map: tex });
        const sprite = new THREE.Sprite(mat);
        sprite.position.set(x, y, z);
        sprite.scale.set(size*4, size, 1);
        return sprite;
    }

    // --- Raster und Labels zeichnen ---
    function drawGridAndLabels(s) {
        labelGroup.clear();
        
        const lineMat = new THREE.LineBasicMaterial({ color: 0xcccccc });
        const pts = [];
        
        // Z-Linien (Reihe 1, 2, ...)
        for(let z=0; z<=s.zBays; z++) {
            pts.push(new THREE.Vector3(0, 0, z*s.baySize));
            pts.push(new THREE.Vector3(s.xBays*s.baySize, 0, z*s.baySize));
            // Label
            const label = createLabel(`Reihe ${z+1}`, -4, 0, z*s.baySize);
            labelGroup.add(label);
        }
        
        // X-Linien (Reihe A, B, ...)
        const abc = "ABCDEFGHIJ";
        for(let x=0; x<=s.xBays; x++) {
            pts.push(new THREE.Vector3(x*s.baySize, 0, 0));
            pts.push(new THREE.Vector3(x*s.baySize, 0, s.zBays*s.baySize));
            // Label
            const label = createLabel(`Reihe ${abc[x]}`, x*s.baySize, 0, s.zBays*s.baySize + 2);
            labelGroup.add(label);
        }
        labelGroup.add(new THREE.LineSegments(new THREE.BufferGeometry().setFromPoints(pts), lineMat));

        // Ebene Labels (Höhe)
        for(let y=1; y<=s.maxLevel; y++) {
            const label = createLabel(`Ebene ${y}`, -4, y*s.heightSize, -2, '#0056b3');
            labelGroup.add(label);
        }
    }

    // --- 2. Systemgenerierung ---
    function generateNewProblem() {
        try {
            resetUserBraces();
            
            const xBaysMax = Math.floor(Math.random()*2) + 3; 
            const zBaysMax = Math.floor(Math.random()*2) + 2; 
            const maxLevel = Math.floor(Math.random()*2) + 2; 
            
            let gridHeights = [];
            for(let x=0; x<xBaysMax; x++) {
                let row = [];
                for(let z=0; z<zBaysMax; z++) {
                    let h = maxLevel;
                    if(Math.random() > 0.5) h -= 1;
                    if(x===0 && z===0) h = maxLevel; 
                    row.push(Math.max(0, h));
                }
                gridHeights.push(row);
            }

            structureData = { 
                xBays: xBaysMax, zBays: zBaysMax, maxLevel, 
                gridHeights, baySize: 4, heightSize: 3 
            };

            indexNodes(); 
            calculatePerf(); 
            drawStructure3DComplex(); 
            create2DPanelsComplex(); 
            
            document.getElementById('status-bar').innerText = "Ein neues System wurde generiert.";
            document.getElementById('status-bar').style.background = "#fff3cd";
            document.getElementById('status-bar').style.color = "#333";
        } catch (e) { console.error(e); }
    }

    function getBayHeight(x, z) {
        const s = structureData;
        if (!s.gridHeights || x < 0 || x >= s.xBays || z < 0 || z >= s.zBays) return 0;
        return s.gridHeights[x][z];
    }

    function isNodeValid(x, y, z) {
        if (y === 0) {
            return Math.max(getBayHeight(x, z), getBayHeight(x-1, z), getBayHeight(x, z-1), getBayHeight(x-1, z-1)) > 0;
        } else {
            let maxH = 0;
            maxH = Math.max(maxH, getBayHeight(x, z));
            maxH = Math.max(maxH, getBayHeight(x-1, z));
            maxH = Math.max(maxH, getBayHeight(x, z-1));
            maxH = Math.max(maxH, getBayHeight(x-1, z-1));
            return y <= maxH && maxH > 0;
        }
    }

    function indexNodes() {
        nodeList = [];
        const s = structureData;
        for(let y=0; y<=s.maxLevel; y++) {
            for(let z=0; z<=s.zBays; z++) {
                for(let x=0; x<=s.xBays; x++) {
                    if(isNodeValid(x,y,z)) nodeList.push({ x, y, z, id: nodeList.length });
                }
            }
        }
    }

    // --- p_erf Berechnung ---
    function calculatePerf() {
        const s = structureData;
        let k = 0;
        let bars = 0;

        for(let n of nodeList) {
            if(n.y > 0) k++;
            if(n.y > 0 && isNodeValid(n.x, n.y-1, n.z)) bars++; 
            if(n.y > 0) {
                if(isNodeValid(n.x+1, n.y, n.z)) bars++; 
                if(isNodeValid(n.x, n.y, n.z+1)) bars++; 
            }
        }

        const p_vorh = bars;
        perfValue = 3 * k - p_vorh;

        document.getElementById('perf-val').innerText = perfValue;
        document.getElementById('k-val').innerText = k;
        document.getElementById('pvorh-val').innerText = p_vorh;
    }

    // --- 3. 3D-Darstellung ---
    function drawStructure3DComplex() {
        frameGroup.clear();
        elementMeshes = [];
        const s = structureData;
        
        // Raster und Labels zeichnen
        drawGridAndLabels(s);

        const frameMat = new THREE.MeshLambertMaterial({ color: 0x444444 });
        const nodeMat = new THREE.MeshLambertMaterial({ color: 0x222222 });

        for(let n of nodeList) {
            const px=n.x*s.baySize, py=n.y*s.heightSize, pz=n.z*s.baySize;
            
            // Knotengröße reduziert (0.12)
            const nm = new THREE.Mesh(new THREE.SphereGeometry(0.12, 16, 16), nodeMat);
            nm.position.set(px,py,pz); frameGroup.add(nm);

            const drawBeam = (tx, ty, tz) => {
                const v1 = new THREE.Vector3(px, py, pz);
                const v2 = new THREE.Vector3(tx, ty, tz);
                const dist = v1.distanceTo(v2);
                const cyl = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, dist, 8), frameMat.clone());
                cyl.position.copy(v1).add(v2).multiplyScalar(0.5);
                cyl.lookAt(v2); cyl.rotateX(Math.PI/2);
                frameGroup.add(cyl);
                elementMeshes.push(cyl); 
            };

            if(n.y>0 && isNodeValid(n.x, n.y-1, n.z)) drawBeam(n.x*s.baySize, (n.y-1)*s.heightSize, n.z*s.baySize);
            if(n.y>0) {
                if(isNodeValid(n.x+1, n.y, n.z)) drawBeam((n.x+1)*s.baySize, n.y*s.heightSize, n.z*s.baySize);
                if(isNodeValid(n.x, n.y, n.z+1)) drawBeam(n.x*s.baySize, n.y*s.heightSize, (n.z+1)*s.baySize);
            }
            if(n.y===0) {
                const cone = new THREE.Mesh(new THREE.ConeGeometry(0.4, 0.8, 8), new THREE.MeshLambertMaterial({color:0x666666}));
                cone.position.set(px, py-0.4, pz); frameGroup.add(cone);
            }
        }
        controls.target.set((s.xBays*s.baySize)/2, (s.maxLevel*s.heightSize)/2, (s.zBays*s.baySize)/2);
    }

    // --- 4. Musterlösung (L-Regel) ---
    function showSolution() {
        clearSolution(); 
        const mode = document.getElementById('modeSelect').value;
        const s = structureData;

        const addSol = (x1,y1,z1, x2,y2,z2) => {
            if(!isNodeValid(x1,y1,z1) || !isNodeValid(x2,y2,z2)) return;
            const v1 = new THREE.Vector3(x1*s.baySize, y1*s.heightSize, z1*s.baySize);
            const v2 = new THREE.Vector3(x2*s.baySize, y2*s.heightSize, z2*s.baySize);
            const dist = v1.distanceTo(v2);
            const cyl = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, dist, 8), new THREE.MeshLambertMaterial({color: 0x198754}));
            cyl.position.copy(v1).add(v2).multiplyScalar(0.5); cyl.lookAt(v2); cyl.rotateX(Math.PI/2);
            solutionBraceGroup.add(cyl);
            document.querySelectorAll('svg').forEach(svg => {
                const n1 = svg.querySelector(`circle[data-x="${x1}"][data-y="${y1}"][data-z="${z1}"]`);
                const n2 = svg.querySelector(`circle[data-x="${x2}"][data-y="${y2}"][data-z="${z2}"]`);
                if(n1 && n2) {
                    const l = document.createElementNS('http://www.w3.org/2000/svg','line');
                    l.setAttribute('x1',n1.dataset.sx); l.setAttribute('y1',n1.dataset.sy);
                    l.setAttribute('x2',n2.dataset.sx); l.setAttribute('y2',n2.dataset.sy);
                    l.setAttribute('class','solution-brace');
                    svg.querySelector('.usr-l').appendChild(l);
                }
            });
        };

        if (mode === 'scheiben') {
            for(let y=1; y<=s.maxLevel; y++) {
                let zBackbone = -1;
                for(let z=0; z<s.zBays; z++) {
                    let hasFloor = false;
                    for(let x=0; x<s.xBays; x++) if(s.gridHeights[x][z] >= y) hasFloor = true;
                    if(hasFloor) { zBackbone = z; break; }
                }
                let xBackbone = -1;
                for(let x=0; x<s.xBays; x++) {
                    let hasFloor = false;
                    for(let z=0; z<s.zBays; z++) if(s.gridHeights[x][z] >= y) hasFloor = true;
                    if(hasFloor) { xBackbone = x; break; }
                }
                if(zBackbone !== -1) {
                    for(let x=0; x<s.xBays; x++) if(s.gridHeights[x][zBackbone] >= y) addSol(x, y, zBackbone, x+1, y, zBackbone+1);
                }
                if(xBackbone !== -1) {
                    for(let z=0; z<s.zBays; z++) {
                        if(s.gridHeights[xBackbone][z] >= y) {
                            if(z !== zBackbone) addSol(xBackbone, y, z, xBackbone+1, y, z+1);
                        }
                    }
                }
                let foundBack = false; for(let z=0; z<s.zBays; z++) { for(let x=0; x<s.xBays; x++) { if(getBayHeight(x,z)>=y) { addSol(x, y, z, x+1, y-1, z); foundBack=true; break; } } if(foundBack) break; }
                let foundFront = false; for(let z=s.zBays-1; z>=0; z--) { for(let x=s.xBays-1; x>=0; x--) { if(getBayHeight(x,z)>=y) { addSol(x, y, z+1, x+1, y-1, z+1); foundFront=true; break; } } if(foundFront) break; }
                let foundSide = false; for(let x=0; x<s.xBays; x++) { for(let z=0; z<s.zBays; z++) { if(getBayHeight(x,z)>=y) { addSol(x, y, z, x, y-1, z+1); foundSide=true; break; } } if(foundSide) break; }
            }
        } else {
            for(let y=1; y<=s.maxLevel; y++) {
                for(let z=0; z<=s.zBays; z++) for(let x=0; x<s.xBays; x++) if(isNodeValid(x,y,z)&&isNodeValid(x+1,y,z)) { addSol(x,y,z, x+1,y-1,z); break; }
                for(let x=0; x<=s.xBays; x++) for(let z=0; z<s.zBays; z++) if(isNodeValid(x,y,z)&&isNodeValid(x,y,z+1)) { addSol(x,y,z, x,y-1,z+1); break; }
            }
        }
        document.getElementById('status-bar').innerText = "Musterlösung (L-Regel) wird angezeigt.";
    }

    function clearSolution() {
        solutionBraceGroup.clear();
        document.querySelectorAll('line.solution-brace').forEach(e => e.remove());
    }

    // --- 5. Statische Berechnung ---
    function analyzeStructure() {
        const s = structureData;
        const nNodes = nodeList.length;
        const nDOF = nNodes * 3; 
        
        let K = new Float64Array(nDOF * nDOF); 
        function kSet(r, c, v) { if(r<nDOF && c<nDOF) K[r*nDOF + c] += v; }

        let elements = [];
        for(let n of nodeList) {
            if(n.y > 0 && isNodeValid(n.x, n.y-1, n.z)) elements.push([n, nodeList.find(nn=>nn.x===n.x && nn.y===n.y-1 && nn.z===n.z)]);
            if(n.y > 0) {
                if(isNodeValid(n.x+1, n.y, n.z)) elements.push([n, nodeList.find(nn=>nn.x===n.x+1 && nn.y===n.y && nn.z===n.z)]);
                if(isNodeValid(n.x, n.y, n.z+1)) elements.push([n, nodeList.find(nn=>nn.x===n.x && nn.y===n.y && nn.z===n.z+1)]);
            }
        }
        for(let b of userBraces) {
            let n1 = nodeList.find(n => n.x===b.p1.x && n.y===b.p1.y && n.z===b.p1.z);
            let n2 = nodeList.find(n => n.x===b.p2.x && n.y===b.p2.y && n.z===b.p2.z);
            if(n1 && n2) elements.push([n1, n2]);
        }

        const EA_L = 1000; 
        for(let el of elements) {
            let n1 = el[0], n2 = el[1];
            let idx1 = n1.id * 3, idx2 = n2.id * 3;
            let dx = (n2.x - n1.x) * s.baySize, dy = (n2.y - n1.y) * s.heightSize, dz = (n2.z - n1.z) * s.baySize;
            let L = Math.sqrt(dx*dx + dy*dy + dz*dz);
            if(L===0) continue;
            let cx = dx/L, cy = dy/L, cz = dz/L;
            let T = [cx, cy, cz];
            for(let i=0; i<3; i++) {
                for(let j=0; j<3; j++) {
                    let val = EA_L * T[i] * T[j];
                    kSet(idx1+i, idx1+j, val); kSet(idx1+i, idx2+j, -val); kSet(idx2+i, idx1+j, -val); kSet(idx2+i, idx2+j, val);
                }
            }
        }

        for(let n of nodeList) {
            if(n.y === 0) {
                let idx = n.id * 3; let p = 1e15;
                kSet(idx, idx, p); kSet(idx+1, idx+1, p); kSet(idx+2, idx+2, p);
            }
        }

        let F = new Float64Array(nDOF);
        for(let n of nodeList) { if(n.y > 0 && n.y === getBayHeight(n.x, n.z)) { F[n.id*3] = 20; F[n.id*3 + 2] = 10; } }

        let u = solveLinearSystem(K, F, nDOF);
        const sb = document.getElementById('status-bar');
        
        if(u === null) {
            sb.innerText = "❌ Einsturzgefahr! (Strukturell instabil / Singular Matrix)";
            sb.style.background = "#f8d7da"; sb.style.color = "#721c24";
        } else {
            let maxDisp = 0; for(let val of u) maxDisp = Math.max(maxDisp, Math.abs(val));
            if(maxDisp > 1e4) {
                sb.innerText = `❌ Einsturzgefahr! (Zu große Verformung: ${maxDisp.toExponential(2)})`;
                sb.style.background = "#f8d7da"; sb.style.color = "#721c24";
            } else {
                sb.innerText = `✅ Strukturell stabil! (Max. Verformung: ${maxDisp.toFixed(4)})`;
                sb.style.background = "#d1e7dd"; sb.style.color = "#0f5132";
            }
        }
    }

    function solveLinearSystem(A, b, n) {
        let M = new Float64Array(A); let x = new Float64Array(b);
        for(let k=0; k<n; k++) {
            let maxVal = Math.abs(M[k*n + k]), maxRow = k;
            for(let i=k+1; i<n; i++) if(Math.abs(M[i*n + k]) > maxVal) { maxVal = Math.abs(M[i*n + k]); maxRow = i; }
            if(Math.abs(maxVal) < 1e-9) return null; 
            for(let j=k; j<n; j++) { let t = M[k*n + j]; M[k*n + j] = M[maxRow*n + j]; M[maxRow*n + j] = t; }
            let tB = x[k]; x[k] = x[maxRow]; x[maxRow] = tB;
            for(let i=k+1; i<n; i++) {
                let f = M[i*n + k] / M[k*n + k];
                for(let j=k; j<n; j++) M[i*n + j] -= f * M[k*n + j];
                x[i] -= f * x[k];
            }
        }
        for(let i=n-1; i>=0; i--) {
            let sum = 0; for(let j=i+1; j<n; j++) sum += M[i*n + j] * x[j];
            x[i] = (x[i] - sum) / M[i*n + i];
        }
        return x;
    }

    // --- 6. 2D-Paneele erstellen ---
    function create2DPanelsComplex() {
        const c = document.getElementById('draw-area');
        const s = structureData;
        const sc = 25; 
        let h = '';
        
        try {
            h += `<div class="panel-group"><span class="panel-title">Reihen (Z-Ansichten)</span><div class="svg-container">`;
            for(let z=0; z<=s.zBays; z++) h += makeSVG(`z-view-${z}`, `Reihe ${z+1}`, s.xBays, s.maxLevel, sc, 'z', z);
            h += `</div></div>`;
            h += `<div class="panel-group"><span class="panel-title">Reihen (X-Ansichten)</span><div class="svg-container">`;
            const abc = "ABCDE";
            for(let x=0; x<=s.xBays; x++) h += makeSVG(`x-view-${x}`, `Reihe ${abc[x]}`, s.zBays, s.maxLevel, sc, 'x', x);
            h += `</div></div>`;
            h += `<div class="panel-group"><span class="panel-title">Decken (Draufsichten)</span><div class="svg-container">`;
            for(let y=1; y<=s.maxLevel; y++) h += makeSVG(`y-view-${y}`, `Ebene ${y}`, s.xBays, s.zBays, sc, 'y', y);
            h += `</div></div>`;
            
            c.innerHTML = h;
            document.querySelectorAll('.node').forEach(n => n.addEventListener('click', onNodeClick));
        } catch(e) { console.error("2D Error:", e); }
    }

    function makeSVG(id, title, c, r, sc, axis, idx) {
        let lines = '', nodes = '';
        for(let i=0; i<=r; i++) {
            for(let j=0; j<=c; j++) {
                let x3,y3,z3;
                if(axis==='z') { x3=j; y3=r-i; z3=idx; }
                if(axis==='x') { x3=idx; y3=r-i; z3=j; }
                if(axis==='y') { x3=j; y3=idx; z3=i; }
                
                if(!isNodeValid(x3, y3, z3)) continue;

                if(axis!=='y' && j<c && isNodeValid(x3+(axis==='z'?1:0), y3, z3+(axis==='x'?1:0))) 
                    lines+=`<line x1="${20+j*sc}" y1="${20+i*sc}" x2="${20+(j+1)*sc}" y2="${20+i*sc}" class="frame"/>`;
                if(axis!=='y' && i<r && isNodeValid(x3, y3-1, z3))
                    lines+=`<line x1="${20+j*sc}" y1="${20+i*sc}" x2="${20+j*sc}" y2="${20+(i+1)*sc}" class="frame"/>`;
                if(axis==='y' && j<c && isNodeValid(x3+1, y3, z3))
                     lines+=`<line x1="${20+j*sc}" y1="${20+i*sc}" x2="${20+(j+1)*sc}" y2="${20+i*sc}" class="frame"/>`;
                if(axis==='y' && i<r && isNodeValid(x3, y3, z3+1))
                     lines+=`<line x1="${20+j*sc}" y1="${20+i*sc}" x2="${20+j*sc}" y2="${20+(i+1)*sc}" class="frame"/>`;

                const cls = (y3===0) ? 'node ground' : 'node';
                nodes += `<circle cx="${20+j*sc}" cy="${20+i*sc}" r="4" class="${cls}" 
                        data-x="${x3}" data-y="${y3}" data-z="${z3}" 
                        data-sx="${20+j*sc}" data-sy="${20+i*sc}"></circle>`;
            }
        }
        return `<div class="svg-wrapper"><div style="font-size:13px;margin-bottom:5px;">${title}</div><svg id="${id}" width="${c*sc+40}" height="${r*sc+40}"><g class="usr-l"></g>${lines}${nodes}</svg></div>`;
    }

    // --- Interaktion ---
    function onNodeClick(e) {
        const t = e.target;
        if(!selectedNode) { 
            selectedNode = t; 
            t.classList.add('selected'); 
        } 
        else {
            if(selectedNode.closest('svg') !== t.closest('svg')) { 
                alert("Verbindung nur innerhalb derselben Zeichnung möglich."); 
                selectedNode.classList.remove('selected'); 
                selectedNode=null; 
                return; 
            }
            if(selectedNode === t) { 
                selectedNode.classList.remove('selected'); 
                selectedNode=null; 
                return; 
            }
            addBrace(selectedNode, t); 
            selectedNode.classList.remove('selected'); 
            selectedNode=null;
        }
    }

    function addBrace(n1, n2) {
        const p1 = {x:parseInt(n1.dataset.x), y:parseInt(n1.dataset.y), z:parseInt(n1.dataset.z)};
        const p2 = {x:parseInt(n2.dataset.x), y:parseInt(n2.dataset.y), z:parseInt(n2.dataset.z)};
        
        let braceData = { p1, p2, svg: null, mesh: null };
        userBraces.push(braceData);
        
        const svg = n1.closest('svg');
        const l = document.createElementNS('http://www.w3.org/2000/svg','line');
        l.setAttribute('x1', n1.dataset.sx); l.setAttribute('y1', n1.dataset.sy);
        l.setAttribute('x2', n2.dataset.sx); l.setAttribute('y2', n2.dataset.sy);
        l.setAttribute('class','brace');
        
        l.addEventListener('click', (e) => {
            e.stopPropagation();
            if(confirm('Möchten Sie diesen Stab entfernen?')) removeBrace(braceData);
        });
        
        svg.querySelector('.usr-l').appendChild(l);
        braceData.svg = l;
        
        const s = structureData;
        const v1 = new THREE.Vector3(p1.x*s.baySize, p1.y*s.heightSize, p1.z*s.baySize);
        const v2 = new THREE.Vector3(p2.x*s.baySize, p2.y*s.heightSize, p2.z*s.baySize);
        const dist = v1.distanceTo(v2);
        const cyl = new THREE.Mesh(new THREE.CylinderGeometry(0.08,0.08,dist,8), new THREE.MeshLambertMaterial({color:0xdc3545}));
        cyl.position.copy(v1).add(v2).multiplyScalar(0.5); 
        cyl.lookAt(v2); cyl.rotateX(Math.PI/2);
        userBraceGroup.add(cyl);
        braceData.mesh = cyl;
    }

    function removeBrace(braceData) {
        userBraces = userBraces.filter(b => b !== braceData);
        if(braceData.svg) braceData.svg.remove();
        if(braceData.mesh) userBraceGroup.remove(braceData.mesh);
        document.getElementById('status-bar').innerText = "Stab entfernt.";
    }

    function resetUserBraces() {
        userBraces = []; 
        userBraceGroup.clear();
        clearSolution();
        
        selectedNode = null;
        document.querySelectorAll('line.brace').forEach(e=>e.remove());
        document.querySelectorAll('.node.selected').forEach(e=>e.classList.remove('selected'));
        document.getElementById('status-bar').innerText = "Zurückgesetzt.";
        document.getElementById('status-bar').style.background = "#fff3cd";
    }
</script>
</body>
</html>