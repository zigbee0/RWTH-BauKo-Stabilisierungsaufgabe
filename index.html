<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <title>Tragwerks-Stabilisator</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        body { margin: 0; font-family: 'Segoe UI', sans-serif; display: flex; height: 100vh; overflow: hidden; background-color: #f8f9fa; }
        #left-panel { width: 45%; height: 100%; position: relative; border-right: 1px solid #ddd; }
        #right-panel { width: 55%; height: 100%; display: flex; flex-direction: column; background: white; }
        #view3d { width: 100%; height: 100%; background: #eef2f5; }

        #calc-header { padding: 15px 20px; background: #fff; border-bottom: 1px solid #ddd; box-shadow: 0 2px 4px rgba(0,0,0,0.05); }
        .formula-box { background: #f0f7ff; padding: 15px; border-radius: 8px; border-left: 5px solid #0056b3; font-family: monospace; }
        .formula-title { font-size: 1.3em; font-weight: bold; color: #333; margin-bottom: 8px; }
        .formula-desc { font-size: 0.9em; color: #555; line-height: 1.6; }
        .val-highlight { color: #d63384; font-weight: bold; font-size: 1.2em; }
        .badge { background: #0056b3; color: white; padding: 2px 6px; border-radius: 4px; font-size: 0.7em; vertical-align: text-top; margin-left: 5px;}

        #toolbar { padding: 10px 20px; background: #e9ecef; border-bottom: 1px solid #ccc; display: flex; justify-content: space-between; align-items: center; }
        select { padding: 8px; border-radius: 4px; border: 1px solid #aaa; font-weight: bold; }
        button { padding: 8px 15px; border: none; border-radius: 4px; cursor: pointer; color: white; margin-left: 5px; font-weight: bold; transition: 0.2s; font-size: 13px; }
        .btn-new { background: #6c757d; } 
        .btn-check { background: #6610f2; color: white; } 
        .btn-solve { background: #28a745; } 
        .btn-reset { background: #dc3545; }
        button:hover { transform: translateY(-1px); opacity: 0.9; }

        #status-bar { padding: 12px 20px; background: #fff3cd; color: #333; font-size: 14px; border-bottom: 1px solid #ffeeba; min-height: 20px; font-weight: bold;}
        #draw-area { flex: 1; overflow-y: auto; padding: 20px; }
        
        .panel-group { margin-bottom: 25px; border: 1px solid #eee; border-radius: 8px; padding: 15px; background: #fff; }
        .panel-title { font-weight: bold; display: block; margin-bottom: 10px; color: #444; border-bottom: 2px solid #eee; padding-bottom: 5px; }
        .svg-container { display: flex; flex-wrap: wrap; gap: 20px; justify-content: center; }
        .svg-wrapper { text-align: center; }
        svg { border: 1px solid #ccc; background: white; user-select: none; }
        
        circle.node { fill: #fff; stroke: #333; stroke-width: 1.5px; cursor: pointer; transition: 0.2s; }
        circle.node:hover { fill: #aaa; r: 6; } 
        circle.node.selected { fill: #ff0000; stroke: #ff0000; r: 5; }
        circle.node.ground { fill: #bbb; stroke: #888; cursor: pointer; } 
        line.frame { stroke: #e0e0e0; stroke-width: 2px; }
        line.brace { stroke: #dc3545; stroke-width: 4px; stroke-linecap: round; cursor: pointer; transition: stroke 0.2s; }
        line.brace:hover { stroke: #ff0000; stroke-width: 6px; }
        line.solution-brace { stroke: #198754; stroke-width: 3px; stroke-dasharray: 5,5; opacity: 0.8; pointer-events: none; }
    </style>
</head>
<body>

<div id="left-panel"><div id="view3d"></div></div>

<div id="right-panel">
    <div id="calc-header">
        <div class="formula-box">
            <div class="formula-title">
                p<sub>erf</sub> = 3 · k - p<sub>vorh</sub> = <span id="perf-val" class="val-highlight">0</span>
                <span class="badge">Formel nach Vorlesung</span>
            </div>
            <div class="formula-desc">
                • <strong>k (Knoten):</strong> <span id="k-val">0</span> (Anz. Knoten ohne Auflagerknoten)<br>
                • <strong>p<sub>vorh</sub> (Stäbe):</strong> <span id="pvorh-val">0</span> 
                (Anzahl Stäbe inkl. Stützen am Boden)
            </div>
        </div>
    </div>

    <div id="toolbar">
        <select id="modeSelect" onchange="resetUserBraces()">
            <option value="scheiben">Scheibenstabilisierung</option>
            <option value="reihen">Reihenstabilisierung</option>
        </select>
        <div>
            <button class="btn-new" onclick="generateNewProblem()">Neues System</button>
            <button class="btn-reset" onclick="resetUserBraces()">Zurücksetzen</button>
            <button class="btn-solve" onclick="showSolution()">Lösung zeigen</button>
            <button class="btn-check" onclick="analyzeStructure()">System prüfen</button>
        </div>
    </div>
    
    <div id="status-bar">Bereit.</div>
    <div id="draw-area"></div>
</div>

<script>
    let scene, camera, renderer, controls;
    let structureData = {};
    let userBraces = []; 
    let nodeList = []; 
    let selectedNode = null; 
    let perfValue = 0;

    const frameGroup = new THREE.Group();
    const userBraceGroup = new THREE.Group();
    const solutionBraceGroup = new THREE.Group();
    const labelGroup = new THREE.Group();
    const torsionArrowGroup = new THREE.Group(); // Gruppe für den Torsionspfeil

    init3D();
    generateNewProblem();

    function disposeGroup(group) {
        while (group.children.length > 0) {
            const child = group.children[0];
            group.remove(child);
            if (child.geometry) child.geometry.dispose();
            if (child.material) {
                if (Array.isArray(child.material)) child.material.forEach(mat => { if(mat.map) mat.map.dispose(); mat.dispose(); });
                else { if (child.material.map) child.material.map.dispose(); child.material.dispose(); }
            }
        }
    }

    function init3D() {
        const container = document.getElementById('view3d');
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xeef2f5);
        const aspect = container.clientWidth / container.clientHeight;
        const d = 40; 
        camera = new THREE.OrthographicCamera(-d*aspect, d*aspect, d, -d, 1, 1000);
        camera.position.set(50, 50, 50); 
        camera.lookAt(scene.position);
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(container.clientWidth, container.clientHeight);
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        scene.add(new THREE.AmbientLight(0xffffff, 0.8));
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.5);
        dirLight.position.set(20, 50, 20);
        scene.add(dirLight);
        
        scene.add(frameGroup);
        scene.add(userBraceGroup);
        scene.add(solutionBraceGroup);
        scene.add(labelGroup);
        scene.add(torsionArrowGroup); // Pfeil-Gruppe zur Szene hinzufügen
        
        animate();
        window.addEventListener('resize', () => {
            const aspect = container.clientWidth / container.clientHeight;
            camera.left = -d*aspect; camera.right = d*aspect;
            camera.updateProjectionMatrix();
            renderer.setSize(container.clientWidth, container.clientHeight);
        });
    }
    function animate() { requestAnimationFrame(animate); controls.update(); renderer.render(scene, camera); }

    function createLabel(text, x, y, z, color='#333', size=1.5) {
        const canvas = document.createElement('canvas');
        const ctx = canvas.getContext('2d');
        canvas.width = 256; canvas.height = 64; 
        ctx.font = 'Bold 32px Arial'; ctx.fillStyle = color; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillText(text, 128, 32);
        const tex = new THREE.CanvasTexture(canvas);
        const mat = new THREE.SpriteMaterial({ map: tex });
        const sprite = new THREE.Sprite(mat);
        sprite.position.set(x, y, z); sprite.scale.set(size*4, size, 1);
        return sprite;
    }

    function drawGridAndLabels(s) {
        disposeGroup(labelGroup);
        const lineMat = new THREE.LineBasicMaterial({ color: 0xcccccc });
        const pts = [];
        for(let z=0; z<=s.zBays; z++) {
            pts.push(new THREE.Vector3(0, 0, z*s.baySize)); pts.push(new THREE.Vector3(s.xBays*s.baySize, 0, z*s.baySize));
            labelGroup.add(createLabel(`Reihe ${z+1}`, -4, 0, z*s.baySize));
        }
        const abc = "ABCDEFGHIJ";
        for(let x=0; x<=s.xBays; x++) {
            pts.push(new THREE.Vector3(x*s.baySize, 0, 0)); pts.push(new THREE.Vector3(x*s.baySize, 0, s.zBays*s.baySize));
            labelGroup.add(createLabel(`Reihe ${abc[x]}`, x*s.baySize, 0, s.zBays*s.baySize + 2));
        }
        labelGroup.add(new THREE.LineSegments(new THREE.BufferGeometry().setFromPoints(pts), lineMat));
        for(let y=1; y<=s.maxLevel; y++) labelGroup.add(createLabel(`Ebene ${y}`, -4, y*s.heightSize, -2, '#0056b3'));
    }

    function generateNewProblem() {
        try {
            resetUserBraces();
            const xBaysMax = Math.floor(Math.random()*2) + 2; 
            const zBaysMax = Math.floor(Math.random()*2) + 2; 
            const maxLevel = Math.floor(Math.random()*2) + 3; 
            
            let gridHeights = [];
            for(let x=0; x<xBaysMax; x++) {
                let row = [];
                for(let z=0; z<zBaysMax; z++) {
                    let h = maxLevel;
                    if(Math.random() > 0.5) h -= 3;
                    if(x===0 && z===0) h = maxLevel; 
                    row.push(Math.max(0, h));
                }
                gridHeights.push(row);
            }

            structureData = { xBays: xBaysMax, zBays: zBaysMax, maxLevel, gridHeights, baySize: 4, heightSize: 3 };
            indexNodes(); calculatePerf(); drawStructure3DComplex(); create2DPanelsComplex();
            setStatus("Ein neues System wurde generiert.", "#fff3cd", "#333");
        } catch (e) { console.error(e); }
    }

    function setStatus(text, bg, color) {
        const sb = document.getElementById('status-bar');
        sb.innerText = text; sb.style.background = bg; sb.style.color = color;
    }

    function getBayHeight(x, z) {
        const s = structureData;
        if (!s.gridHeights || x < 0 || x >= s.xBays || z < 0 || z >= s.zBays) return 0;
        return s.gridHeights[x][z];
    }

    function isNodeValid(x, y, z) {
        if (y === 0) return Math.max(getBayHeight(x, z), getBayHeight(x-1, z), getBayHeight(x, z-1), getBayHeight(x-1, z-1)) > 0;
        else {
            let maxH = Math.max(getBayHeight(x, z), getBayHeight(x-1, z), getBayHeight(x, z-1), getBayHeight(x-1, z-1));
            return y <= maxH && maxH > 0;
        }
    }

    function indexNodes() {
        nodeList = [];
        const s = structureData;
        for(let y=0; y<=s.maxLevel; y++) {
            for(let z=0; z<=s.zBays; z++) {
                for(let x=0; x<=s.xBays; x++) {
                    if(isNodeValid(x,y,z)) nodeList.push({ x, y, z, id: nodeList.length });
                }
            }
        }
    }

    function calculatePerf() {
        const s = structureData;
        let k = 0; let bars = 0;
        for(let n of nodeList) {
            if(n.y > 0) k++;
            if(n.y > 0 && isNodeValid(n.x, n.y-1, n.z)) bars++; 
            if(n.y > 0) {
                if(isNodeValid(n.x+1, n.y, n.z)) bars++; 
                if(isNodeValid(n.x, n.y, n.z+1)) bars++; 
            }
        }
        perfValue = 3 * k - bars;
        document.getElementById('perf-val').innerText = perfValue;
        document.getElementById('k-val').innerText = k;
        document.getElementById('pvorh-val').innerText = bars;
    }

    function drawStructure3DComplex() {
        disposeGroup(frameGroup); 
        const s = structureData;
        drawGridAndLabels(s);
        const frameMat = new THREE.MeshLambertMaterial({ color: 0x444444 });
        const nodeMat = new THREE.MeshLambertMaterial({ color: 0x222222 });

        for(let n of nodeList) {
            const px=n.x*s.baySize, py=n.y*s.heightSize, pz=n.z*s.baySize;
            const nm = new THREE.Mesh(new THREE.SphereGeometry(0.12, 16, 16), nodeMat);
            nm.position.set(px,py,pz); frameGroup.add(nm);

            const drawBeam = (tx, ty, tz) => {
                const v1 = new THREE.Vector3(px, py, pz); const v2 = new THREE.Vector3(tx, ty, tz);
                const dist = v1.distanceTo(v2);
                const cyl = new THREE.Mesh(new THREE.CylinderGeometry(0.08, 0.08, dist, 8), frameMat);
                cyl.position.copy(v1).add(v2).multiplyScalar(0.5); cyl.lookAt(v2); cyl.rotateX(Math.PI/2);
                frameGroup.add(cyl);
            };

            if(n.y>0 && isNodeValid(n.x, n.y-1, n.z)) drawBeam(n.x*s.baySize, (n.y-1)*s.heightSize, n.z*s.baySize);
            if(n.y>0) {
                if(isNodeValid(n.x+1, n.y, n.z)) drawBeam((n.x+1)*s.baySize, n.y*s.heightSize, n.z*s.baySize);
                if(isNodeValid(n.x, n.y, n.z+1)) drawBeam(n.x*s.baySize, n.y*s.heightSize, (n.z+1)*s.baySize);
            }
            if(n.y===0) {
                const cone = new THREE.Mesh(new THREE.ConeGeometry(0.4, 0.8, 8), new THREE.MeshLambertMaterial({color:0x666666}));
                cone.position.set(px, py-0.4, pz); frameGroup.add(cone);
            }
        }
        controls.target.set((s.xBays*s.baySize)/2, (s.maxLevel*s.heightSize)/2, (s.zBays*s.baySize)/2);
    }

    // --- 4. Musterlösung ---
    function showSolution() {
        clearSolution(); 
        disposeGroup(torsionArrowGroup); // Torsionspfeile zurücksetzen
        const mode = document.getElementById('modeSelect').value;
        const s = structureData;
        let placedCount = 0;

        const addSol = (x1,y1,z1, x2,y2,z2) => {
            if(!isNodeValid(x1,y1,z1) || !isNodeValid(x2,y2,z2)) return;
            const v1 = new THREE.Vector3(x1*s.baySize, y1*s.heightSize, z1*s.baySize);
            const v2 = new THREE.Vector3(x2*s.baySize, y2*s.heightSize, z2*s.baySize);
            const dist = v1.distanceTo(v2);
            const cyl = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, dist, 8), new THREE.MeshLambertMaterial({color: 0x198754}));
            cyl.position.copy(v1).add(v2).multiplyScalar(0.5); cyl.lookAt(v2); cyl.rotateX(Math.PI/2);
            solutionBraceGroup.add(cyl);
            document.querySelectorAll('svg').forEach(svg => {
                const n1 = svg.querySelector(`circle[data-x="${x1}"][data-y="${y1}"][data-z="${z1}"]`);
                const n2 = svg.querySelector(`circle[data-x="${x2}"][data-y="${y2}"][data-z="${z2}"]`);
                if(n1 && n2) {
                    const l = document.createElementNS('http://www.w3.org/2000/svg','line');
                    l.setAttribute('x1',n1.dataset.sx); l.setAttribute('y1',n1.dataset.sy);
                    l.setAttribute('x2',n2.dataset.sx); l.setAttribute('y2',n2.dataset.sy);
                    l.setAttribute('class','solution-brace');
                    svg.querySelector('.usr-l').appendChild(l);
                }
            });
            placedCount++;
        };

        if (mode === 'scheiben') {
            let activeFloors = [];
            for(let y=1; y<=s.maxLevel; y++) {
                if (nodeList.some(n => n.y === y)) activeFloors.push(y);
            }

            // 1. Decke (Starre Scheibe - einheitliche Richtung)
            for(let y of activeFloors) {
                let parent = {};
                function find(i) { if (parent[i] === undefined) parent[i] = i; if (parent[i] !== i) parent[i] = find(parent[i]); return parent[i]; }
                function union(i, j) { let rI = find(i), rJ = find(j); if (rI !== rJ) { parent[rI] = rJ; return true; } return false; }

                for(let z=0; z<s.zBays; z++) {
                    for(let x=0; x<s.xBays; x++) {
                        if (isNodeValid(x,y,z) && isNodeValid(x+1,y,z) && isNodeValid(x,y,z+1) && isNodeValid(x+1,y,z+1)) {
                            if (union(`X_${x}`, `Z_${z}`)) addSol(x, y, z, x+1, y, z+1);
                        }
                    }
                }
            }

            // 2. Wandscheiben (Vertikale Verbände - Torsion perfekt verhindern)
            let unusedWalls = [];
            for(let y of activeFloors) {
                let wx = []; let wz = [];
                for(let z=0; z<=s.zBays; z++) {
                    for(let x=0; x<s.xBays; x++) { if (isNodeValid(x,y,z) && isNodeValid(x+1,y,z) && isNodeValid(x,y-1,z) && isNodeValid(x+1,y-1,z)) wx.push({x, z, dir:'x'}); }
                }
                for(let x=0; x<=s.xBays; x++) {
                    for(let z=0; z<s.zBays; z++) { if (isNodeValid(x,y,z) && isNodeValid(x,y,z+1) && isNodeValid(x,y-1,z) && isNodeValid(x,y-1,z+1)) wz.push({x, z, dir:'z'}); }
                }

                let w1 = null, w2 = null, w3 = null;
                // Wand 1: X-Richtung
                if (wx.length > 0) { w1 = wx.shift(); addSol(w1.x, y, w1.z, w1.x+1, y-1, w1.z); }
                // Wand 2: Z-Richtung
                if (wz.length > 0) { w2 = wz.shift(); addSol(w2.x, y, w2.z, w2.x, y-1, w2.z+1); }
                
                // Wand 3: Um Torsion (Schnittpunkt) zu vermeiden, muss zwingend eine Wand platziert werden, deren Koordinaten sich von den bisherigen unterscheiden!
                let idxX = wx.findIndex(w => w1 && w.z !== w1.z);
                if (idxX !== -1) { w3 = wx.splice(idxX, 1)[0]; addSol(w3.x, y, w3.z, w3.x+1, y-1, w3.z); } 
                else {
                    let idxZ = wz.findIndex(w => w2 && w.x !== w2.x);
                    if (idxZ !== -1) { w3 = wz.splice(idxZ, 1)[0]; addSol(w3.x, y, w3.z, w3.x, y-1, w3.z+1); }
                }

                // Falls das Gebäude nur 1 Feld breit ist und keine Wand gefunden wird, eine beliebige verbleibende Wand hinzufügen, um 3 Stück zu erreichen
                if (!w3) {
                    if (wx.length > 0) { w3 = wx.shift(); addSol(w3.x, y, w3.z, w3.x+1, y-1, w3.z); }
                    else if (wz.length > 0) { w3 = wz.shift(); addSol(w3.x, y, w3.z, w3.x, y-1, w3.z+1); }
                }
                // Nicht genutzte Wände dieses Geschosses in der Reserve (unused) speichern
                wx.forEach(w => unusedWalls.push({y, ...w}));
                wz.forEach(w => unusedWalls.push({y, ...w}));
            }

            // Nachdem jedes Geschoss 3 Wände erhalten hat, verbleibende Verbände aus der Reserve hinzufügen, bis p_erf exakt erfüllt ist
            let remaining = perfValue - placedCount;
            while (remaining > 0 && unusedWalls.length > 0) {
                let w = unusedWalls.shift();
                if (w.dir === 'x') addSol(w.x, w.y, w.z, w.x+1, w.y-1, w.z);
                else addSol(w.x, w.y, w.z, w.x, w.y-1, w.z+1);
                remaining--;
            }
        } else {
            for(let y=1; y<=s.maxLevel; y++) {
                for(let z=0; z<=s.zBays; z++) for(let x=0; x<s.xBays; x++) if(isNodeValid(x,y,z)&&isNodeValid(x+1,y,z)) { addSol(x,y,z, x+1,y-1,z); break; }
                for(let x=0; x<=s.xBays; x++) for(let z=0; z<s.zBays; z++) if(isNodeValid(x,y,z)&&isNodeValid(x,y,z+1)) { addSol(x,y,z, x,y-1,z+1); break; }
            }
        }
        
        setStatus(mode === 'scheiben' ? `✅ Lösung: Genau ${placedCount} Verbände platziert.` : "Lösung (Reihenstabilisierung) geladen.", "#d1e7dd", "#0f5132");
    }

    // --- NEU: Funktion zum Zeichnen des Torsionsmoment-Pfeils ---
    function showTorsionArrow(cx, cy, cz) {
        disposeGroup(torsionArrowGroup);
        const radius = 2.5; // Radius des Pfeilkreises
        const color = 0xff0000; // Rote Farbe
        
        // Röhre erstellen, die einen 3/4 Kreis (270 Grad) beschreibt
        class ArcCurve extends THREE.Curve {
            getPoint(t, optionalTarget = new THREE.Vector3()) {
                const angle = t * Math.PI * 1.5; 
                return optionalTarget.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);
            }
        }
        
        const tubeGeo = new THREE.TubeGeometry(new ArcCurve(), 64, 0.15, 8, false);
        const mat = new THREE.MeshLambertMaterial({ color: color });
        const tube = new THREE.Mesh(tubeGeo, mat);
        
        // Pfeilspitze (Kegel)
        const coneGeo = new THREE.ConeGeometry(0.4, 1.2, 16);
        const cone = new THREE.Mesh(coneGeo, mat);
        
        // Pfeilspitze bei 270 Grad platzieren und Ausrichtung festlegen
        cone.position.set(0, 0, -radius);
        cone.rotation.x = Math.PI / 2;
        cone.rotation.z = Math.PI / 2;
        
        const arrowGroup = new THREE.Group();
        arrowGroup.add(tube);
        arrowGroup.add(cone);
        
        // Pfeil auf halber Höhe der Stütze am Schnittpunkt platzieren
        arrowGroup.position.set(cx, cy - (structureData.heightSize / 2), cz);
        torsionArrowGroup.add(arrowGroup);
    }

    // --- 5. System prüfen ---
    function analyzeStructure() {
        const mode = document.getElementById('modeSelect').value;
        const s = structureData;
        const sb = document.getElementById('status-bar');
        sb.style.opacity = '0.5'; setTimeout(() => sb.style.opacity = '1', 100);

        disposeGroup(torsionArrowGroup); // Vorhandene Pfeile bei Prüfungsstart entfernen

        let conceptualError = null;

        if (mode === 'scheiben') {
            for (let y = 1; y <= s.maxLevel; y++) {
                if (nodeList.some(n => n.y === y)) {
                    let br = userBraces.filter(b => b.p1.y === y && b.p2.y === y).length;
                    if (br === 0) { conceptualError = `❌ Fehler: Decke Ebene ${y} ist schubweich! (Horizontale Verbände fehlen)`; break; }

                    // Prüfung auf Torsion & Parallelität
                    let xBraces = 0, zBraces = 0;
                    let verticalBraces = userBraces.filter(b => (b.p1.y === y && b.p2.y === y - 1) || (b.p1.y === y - 1 && b.p2.y === y));
                    
                    let uniqueZ_of_X = new Set();
                    let uniqueX_of_Z = new Set();
                    
                    for (let b of verticalBraces) {
                        if (b.p1.z === b.p2.z) { xBraces++; uniqueZ_of_X.add(b.p1.z); } // Wand in X-Richtung
                        if (b.p1.x === b.p2.x) { zBraces++; uniqueX_of_Z.add(b.p1.x); } // Wand in Z-Richtung
                    }

                    if (verticalBraces.length > 0) {
                        // Parallelitätsfehler (Verbände nur in eine Richtung installiert)
                        if (xBraces > 0 && zBraces === 0) { conceptualError = `❌ Fehler (Parallelität): Ebene ${y} ist instabil gegen Z-Kräfte! (Nur X-Verbände)`; break; }
                        if (zBraces > 0 && xBraces === 0) { conceptualError = `❌ Fehler (Parallelität): Ebene ${y} ist instabil gegen X-Kräfte! (Nur Z-Verbände)`; break; }
                        
                        // Prüfung auf Torsionsfehler: Finde den einzigen Schnittpunkt auf der X- und Z-Achse
                        if (uniqueZ_of_X.size === 1 && uniqueX_of_Z.size === 1) {
                            let errX = Array.from(uniqueX_of_Z)[0];
                            let errZ = Array.from(uniqueZ_of_X)[0];
                            const abc = "ABCDEFGHIJ";
                            conceptualError = `❌ Fehler (Torsion): Auf Ebene ${y} schneiden sich alle Verbände in der Achse (Reihe ${abc[errX]} / Reihe ${errZ+1}). Das System verdreht sich!`;
                            
                            // Torsionspfeil erstellen (an der Koordinate des Schnittpunkts)
                            showTorsionArrow(errX * s.baySize, y * s.heightSize, errZ * s.baySize);
                            break;
                        }
                    }
                }
            }
        } else if (mode === 'reihen') {
            if (userBraces.some(b => b.p1.y === b.p2.y)) {
                conceptualError = `❌ Fehler: Bei Reihenstabilisierung muss die Decke schubweich sein!`;
            } else {
                for (let y = 1; y <= s.maxLevel; y++) {
                    for (let z = 0; z <= s.zBays; z++) {
                        let hasWall = false;
                        for (let x = 0; x <= s.xBays; x++) { if (isNodeValid(x, y, z) && isNodeValid(x, y - 1, z)) { hasWall = true; break; } }
                        if (hasWall) {
                            let hasBrace = userBraces.some(b => b.p1.z === z && b.p2.z === z && ((b.p1.y === y && b.p2.y === y - 1) || (b.p1.y === y - 1 && b.p2.y === y)));
                            if (!hasBrace) { conceptualError = `❌ Fehler: In Reihe ${z + 1} (Ebene ${y}) fehlt ein Verband!`; break; }
                        }
                    }
                    if (conceptualError) break;

                    const abc = "ABCDEFGHIJ";
                    for (let x = 0; x <= s.xBays; x++) {
                        let hasWall = false;
                        for (let z = 0; z <= s.zBays; z++) { if (isNodeValid(x, y, z) && isNodeValid(x, y - 1, z)) { hasWall = true; break; } }
                        if (hasWall) {
                            let hasBrace = userBraces.some(b => b.p1.x === x && b.p2.x === x && ((b.p1.y === y && b.p2.y === y - 1) || (b.p1.y === y - 1 && b.p2.y === y)));
                            if (!hasBrace) { conceptualError = `❌ Fehler: In Reihe ${abc[x]} (Ebene ${y}) fehlt ein Verband!`; break; }
                        }
                    }
                    if (conceptualError) break;
                }
            }
        }

        if (conceptualError) return setStatus(conceptualError, "#f8d7da", "#721c24");

        // FEM Berechnung
        const nDOF = nodeList.length * 3; 
        let K = new Float64Array(nDOF * nDOF); 
        function kSet(r, c, v) { if(r<nDOF && c<nDOF) K[r*nDOF + c] += v; }

        let elements = [];
        for(let n of nodeList) {
            if(n.y > 0 && isNodeValid(n.x, n.y-1, n.z)) elements.push([n, nodeList.find(nn=>nn.x===n.x && nn.y===n.y-1 && nn.z===n.z)]);
            if(n.y > 0) {
                if(isNodeValid(n.x+1, n.y, n.z)) elements.push([n, nodeList.find(nn=>nn.x===n.x+1 && nn.y===n.y && nn.z===n.z)]);
                if(isNodeValid(n.x, n.y, n.z+1)) elements.push([n, nodeList.find(nn=>nn.x===n.x && nn.y===n.y && nn.z===n.z+1)]);
            }
        }
        for(let b of userBraces) {
            let n1 = nodeList.find(n => n.x===b.p1.x && n.y===b.p1.y && n.z===b.p1.z);
            let n2 = nodeList.find(n => n.x===b.p2.x && n.y===b.p2.y && n.z===b.p2.z);
            if(n1 && n2) elements.push([n1, n2]);
        }

        for(let el of elements) {
            let dx = (el[1].x - el[0].x) * s.baySize, dy = (el[1].y - el[0].y) * s.heightSize, dz = (el[1].z - el[0].z) * s.baySize;
            let L = Math.sqrt(dx*dx + dy*dy + dz*dz);
            if(L===0) continue;
            let T = [dx/L, dy/L, dz/L];
            for(let i=0; i<3; i++) {
                for(let j=0; j<3; j++) {
                    let v = 1000 * T[i] * T[j];
                    kSet(el[0].id*3+i, el[0].id*3+j, v); kSet(el[0].id*3+i, el[1].id*3+j, -v); 
                    kSet(el[1].id*3+i, el[0].id*3+j, -v); kSet(el[1].id*3+i, el[1].id*3+j, v);
                }
            }
        }

        for(let n of nodeList) {
            if(n.y === 0) {
                let idx = n.id * 3;
                kSet(idx, idx, 1e15); kSet(idx+1, idx+1, 1e15); kSet(idx+2, idx+2, 1e15);
            }
        }

        let F = new Float64Array(nDOF);
        for(let n of nodeList) { if(n.y > 0 && n.y === getBayHeight(n.x, n.z)) { F[n.id*3] = 20; F[n.id*3+2] = 10; } }

        // Gaußsches Eliminationsverfahren
        let M = new Float64Array(K); let x = new Float64Array(F);
        let stable = true;
        for(let k=0; k<nDOF; k++) {
            let maxVal = Math.abs(M[k*nDOF + k]), maxRow = k;
            for(let i=k+1; i<nDOF; i++) if(Math.abs(M[i*nDOF + k]) > maxVal) { maxVal = Math.abs(M[i*nDOF + k]); maxRow = i; }
            if(maxVal < 1e-9) { stable = false; break; } 
            for(let j=k; j<nDOF; j++) { let t = M[k*nDOF + j]; M[k*nDOF + j] = M[maxRow*nDOF + j]; M[maxRow*nDOF + j] = t; }
            let tB = x[k]; x[k] = x[maxRow]; x[maxRow] = tB;
            for(let i=k+1; i<nDOF; i++) {
                let f = M[i*nDOF + k] / M[k*nDOF + k];
                for(let j=k; j<nDOF; j++) M[i*nDOF + j] -= f * M[k*nDOF + j];
                x[i] -= f * x[k];
            }
        }
        
        if (!stable) return setStatus("❌ Einsturzgefahr! (Strukturell instabil / Singular Matrix)", "#f8d7da", "#721c24");

        for(let i=nDOF-1; i>=0; i--) {
            let sum = 0; for(let j=i+1; j<nDOF; j++) sum += M[i*nDOF + j] * x[j];
            x[i] = (x[i] - sum) / M[i*nDOF + i];
        }

        let maxDisp = 0; for(let val of x) maxDisp = Math.max(maxDisp, Math.abs(val));
        if(maxDisp > 1e4) return setStatus(`❌ Einsturzgefahr! (Zu große Verformung)`, "#f8d7da", "#721c24");

        if (mode === 'scheiben') {
            if (userBraces.length > perfValue) return setStatus(`⚠️ Stabil, aber überbestimmt! (${userBraces.length} von p_erf=${perfValue})`, "#cfe2ff", "#084298");
            if (userBraces.length < perfValue) return setStatus(`❌ Fehler: p_erf (${perfValue}) nicht erreicht!`, "#f8d7da", "#721c24");
        }
        
        setStatus(`✅ System ist absolut perfekt! (p_erf eingehalten)`, "#d1e7dd", "#0f5132");
    }

    function create2DPanelsComplex() {
        const c = document.getElementById('draw-area');
        const s = structureData; const sc = 25; 
        let h = '';
        try {
            h += `<div class="panel-group"><span class="panel-title">Reihen (Z-Ansichten)</span><div class="svg-container">`;
            for(let z=0; z<=s.zBays; z++) h += makeSVG(`z-view-${z}`, `Reihe ${z+1}`, s.xBays, s.maxLevel, sc, 'z', z);
            h += `</div></div><div class="panel-group"><span class="panel-title">Reihen (X-Ansichten)</span><div class="svg-container">`;
            for(let x=0; x<=s.xBays; x++) h += makeSVG(`x-view-${x}`, `Reihe ${"ABCDEFGHIJ"[x]}`, s.zBays, s.maxLevel, sc, 'x', x);
            h += `</div></div><div class="panel-group"><span class="panel-title">Decken (Draufsichten)</span><div class="svg-container">`;
            for(let y=1; y<=s.maxLevel; y++) h += makeSVG(`y-view-${y}`, `Ebene ${y}`, s.xBays, s.zBays, sc, 'y', y);
            h += `</div></div>`;
            c.innerHTML = h;
            document.querySelectorAll('.node').forEach(n => n.addEventListener('click', onNodeClick));
        } catch(e) { console.error("2D Error:", e); }
    }

    function makeSVG(id, title, c, r, sc, axis, idx) {
        let lines = '', nodes = '';
        for(let i=0; i<=r; i++) {
            for(let j=0; j<=c; j++) {
                let x3,y3,z3;
                if(axis==='z') { x3=j; y3=r-i; z3=idx; } if(axis==='x') { x3=idx; y3=r-i; z3=j; } if(axis==='y') { x3=j; y3=idx; z3=i; }
                if(!isNodeValid(x3, y3, z3)) continue;
                if(axis!=='y' && j<c && isNodeValid(x3+(axis==='z'?1:0), y3, z3+(axis==='x'?1:0))) lines+=`<line x1="${20+j*sc}" y1="${20+i*sc}" x2="${20+(j+1)*sc}" y2="${20+i*sc}" class="frame"/>`;
                if(axis!=='y' && i<r && isNodeValid(x3, y3-1, z3)) lines+=`<line x1="${20+j*sc}" y1="${20+i*sc}" x2="${20+j*sc}" y2="${20+(i+1)*sc}" class="frame"/>`;
                if(axis==='y' && j<c && isNodeValid(x3+1, y3, z3)) lines+=`<line x1="${20+j*sc}" y1="${20+i*sc}" x2="${20+(j+1)*sc}" y2="${20+i*sc}" class="frame"/>`;
                if(axis==='y' && i<r && isNodeValid(x3, y3, z3+1)) lines+=`<line x1="${20+j*sc}" y1="${20+i*sc}" x2="${20+j*sc}" y2="${20+(i+1)*sc}" class="frame"/>`;
                const cls = (y3===0) ? 'node ground' : 'node';
                nodes += `<circle cx="${20+j*sc}" cy="${20+i*sc}" r="4" class="${cls}" data-x="${x3}" data-y="${y3}" data-z="${z3}" data-sx="${20+j*sc}" data-sy="${20+i*sc}"></circle>`;
            }
        }
        return `<div class="svg-wrapper"><div style="font-size:13px;margin-bottom:5px;">${title}</div><svg id="${id}" width="${c*sc+40}" height="${r*sc+40}"><g class="usr-l"></g>${lines}${nodes}</svg></div>`;
    }

    function onNodeClick(e) {
        const t = e.target;
        if(!selectedNode) { selectedNode = t; t.classList.add('selected'); } 
        else {
            if(selectedNode.closest('svg') !== t.closest('svg')) { alert("Verbindung nur im selben Fenster."); selectedNode.classList.remove('selected'); selectedNode=null; return; }
            if(selectedNode !== t) addBrace(selectedNode, t);
            selectedNode.classList.remove('selected'); selectedNode=null;
        }
    }

    function addBrace(n1, n2) {
        const p1 = {x:parseInt(n1.dataset.x), y:parseInt(n1.dataset.y), z:parseInt(n1.dataset.z)};
        const p2 = {x:parseInt(n2.dataset.x), y:parseInt(n2.dataset.y), z:parseInt(n2.dataset.z)};
        let braceData = { p1, p2, svg: null, mesh: null };
        userBraces.push(braceData);
        const l = document.createElementNS('http://www.w3.org/2000/svg','line');
        l.setAttribute('x1', n1.dataset.sx); l.setAttribute('y1', n1.dataset.sy); l.setAttribute('x2', n2.dataset.sx); l.setAttribute('y2', n2.dataset.sy); l.setAttribute('class','brace');
        l.addEventListener('click', (e) => { e.stopPropagation(); if(confirm('Stab entfernen?')) removeBrace(braceData); });
        n1.closest('svg').querySelector('.usr-l').appendChild(l); braceData.svg = l;
        const s = structureData;
        const v1 = new THREE.Vector3(p1.x*s.baySize, p1.y*s.heightSize, p1.z*s.baySize); const v2 = new THREE.Vector3(p2.x*s.baySize, p2.y*s.heightSize, p2.z*s.baySize);
        const cyl = new THREE.Mesh(new THREE.CylinderGeometry(0.08,0.08,v1.distanceTo(v2),8), new THREE.MeshLambertMaterial({color:0xdc3545}));
        cyl.position.copy(v1).add(v2).multiplyScalar(0.5); cyl.lookAt(v2); cyl.rotateX(Math.PI/2);
        userBraceGroup.add(cyl); braceData.mesh = cyl;
    }

    function removeBrace(braceData) {
        userBraces = userBraces.filter(b => b !== braceData);
        if(braceData.svg) braceData.svg.remove();
        if(braceData.mesh) { userBraceGroup.remove(braceData.mesh); if(braceData.mesh.geometry) braceData.mesh.geometry.dispose(); if(braceData.mesh.material) braceData.mesh.material.dispose(); }
        setStatus("Stab entfernt.", "#fff3cd", "#333");
    }

    function clearSolution() { disposeGroup(solutionBraceGroup); document.querySelectorAll('line.solution-brace').forEach(e => e.remove()); }

    function resetUserBraces() {
        userBraces = []; disposeGroup(userBraceGroup); clearSolution(); disposeGroup(torsionArrowGroup); selectedNode = null;
        document.querySelectorAll('line.brace').forEach(e=>e.remove()); document.querySelectorAll('.node.selected').forEach(e=>e.classList.remove('selected'));
        setStatus("Zurückgesetzt.", "#fff3cd", "#333");
    }
</script>
</body>
</html>
